"use strict";

// TODO: modularize this file

var converter = new Markdown.Converter();
var markdown = function(text) {
  text = text.replace(/\$(.*?)\$/g, '<mathjax data-contents="$1"></mathjax>');
  text = converter.makeHtml(text);
  text = text.replace(/<mathjax data-contents="(.*?)"><\/mathjax>/g, '\\($1\\)');
  return text;
}

window.piBase = window.piBase || {}
window.piBase.formulaInput = function($q) {
  var nameMap = {}
    , idMap   = {}
    , _lookupErrors = []; // TODO: global state bad!

  // var $preview = $('<pre></pre>');
  // $q.after($preview);

  // For previewing: pretend we are done with entering the formula here
  var closeParens = function(str) {
    var stack = [], el;
    _.map(str, function(c) {
      if (c === '{') {
        stack.push('}');
      } else if (c === '[') {
        stack.push(']');
      } else if (c === '}' || c === ']') {
        stack.pop();
      }
    });
    while (el = stack.pop()) {
      str += el;
    }
    return str;
  };

  // Coerce the formula to a JSON AST
  var parse = function(str) {
    return jsonlite.parse(closeParens(str));
  };

  // Allow e.g. lowercase names
  var canonicalizeName = function(name) {
    return name.latinize().toLowerCase().replace(/[${}\(\)\\\s]/g, '');
  };

  // Maps text atoms to submittable id: bool value pairs
  var lookupProps = function(f) {
    if (f.and) {
      return {and: _.map(f.and, lookupProps)};
    } else if (f.or) {
      return {or: _.map(f.or, lookupProps)};
    } else {
      // TODO: fuzzy match, make suggestions if missing
      var name, val, prop, atom;

      if (f[0] === "~" || f[0] === "-" || f[0] === "Â¬") {
        name = f.slice(1, f.length);
        val = false;
      } else {
        name = f;
        val = true;
      };

      prop = nameMap[canonicalizeName(name)];
      if (! prop) {
        _lookupErrors.push(name);
      }

      atom = {}
      atom[prop] = val;
      return atom;
    }
  }

  // Redisplay a JSON formula in its lighter weight format
  var lighten = function(f) {
    if (f.and) {
      return "{and: [" + _.map(f.and, lighten).join(", ") + "]}";
    } else if (f.or) {
      return "{or: [" + _.map(f.or, lighten).join(", ") + "]}";
    } else {
      var kv = _.pairs(f)[0]
        , prefix = kv[1] ? "" : "~";
      return prefix + idMap[""+kv[0]];
    }
  }

  var renderPreview = function() {
    if (!nameMap) return;
    var contents = parse($q.val());
    $preview.html(JSON.stringify(lookupProps(contents), null, 2));
  };

  // Fetch the existing property name <~> id mapping
  //   and render what we need to once we have it
  $.get("@{PropertiesNamesR}", function(data) {
    _.each(data, function(id, name) {
      var cName = canonicalizeName(name);
      if (nameMap[cName]) {
        throw "Name " + cName + " already present";
      };
      nameMap[cName] = id;
      idMap[id] = idMap[id] || cName;
    });

    if ($q.val()) {
      $q.val(lighten(JSON.parse($q.val())));
    };
    // renderPreview();
  });

  // $q.keyup(_.debounce(renderPreview, 500));

  var $errors = $('<div class="alert alert-danger"></div>').hide();
  $q.after($errors);

  var showErrors = function(errors) {
    $errors.show().html("Unrecognized properties: " + errors.join(", "));
  }

  // Convert shorthand to JSON before submitting the form
  $q.closest("form").submit(function(e) {
    var corrected;

    _lookupErrors = [];
    corrected = lookupProps(parse($q.val()));

    if (_lookupErrors.length > 0) {
      showErrors(_lookupErrors);
      _lookupErrors = [];
      e.preventDefault();
      return false;
    } else {
      $q.val(JSON.stringify(corrected));
    }
  });

  // TODO: Add a modal help window
  // var help = $('<i class="fa fa-question form-control-feedback clickable"></i>');
  // help.click(function() { });
  // $q.after(help);
  // $q.parent().addClass("has-feedback");
}


$(function() {
  window.piBase.formulaInput($("#navbar-search"));

  $(".markdown").each(function(i, el) {
    var $el = $(el);
    $el.html(markdown($el.html()));
  });

  // TODO: I'd really like a better way of specifiying this
  //   on a field-by-field basis, but Yesod.Bootstrap3 doesn't seem to expose this
  $(".form-markdown textarea").each(function(i, el) {
    var $el = $(el)
      , $preview = $("<div class='well'></div>");
    $el.attr("rows", 10).after($preview);

    var renderPreview = function() {
      $preview.html(markdown($el.val()));
      MathJax.Hub.Queue(["Typeset", MathJax.Hub, $preview.get(0)]);
    };
    renderPreview();

    $el.keyup(_.debounce(renderPreview, 500));
  });
});
