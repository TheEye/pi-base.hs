"use strict";

// TODO: modularize this file

var converter = new Markdown.Converter();
var markdown = function(text) {
  text = text.replace(/\$(.*?)\$/g, '<mathjax data-contents="$1"></mathjax>');
  text = converter.makeHtml(text);
  text = text.replace(/<mathjax data-contents="(.*?)"><\/mathjax>/g, '\\($1\\)');
  return text;
}

String.prototype.regexIndexOf = function( pattern, startIndex ) {
  startIndex = startIndex || 0;
  var searchResult = this.substr( startIndex ).search( pattern );
  return ( -1 === searchResult ) ? -1 : searchResult + startIndex;
}
String.prototype.regexLastIndexOf = function( pattern, startIndex ) {
  startIndex = startIndex === undefined ? this.length : startIndex;
  var searchResult = this.substr( 0, startIndex ).reverse().regexIndexOf( pattern, 0 );
  return ( -1 === searchResult ) ? -1 : this.length - ++searchResult;
}
String.prototype.reverse = function() {
  return this.split('').reverse().join('');
}

window.piBase = window.piBase || {}
window.piBase.formulaInput = function($q) {
  var nameMap       = {} // simplified name -> id
    , idMap         = {} // id -> display name
    , suggestions   = []
    , _lookupErrors = []; // TODO: global state bad!

  var logError = function(args) {
    if (typeof(Rollbar) === "undefined") { 
      console.error(args);
    } else {
      Rollbar.error.apply(null, args);
    }
  }

  // var $preview = $('<pre></pre>');
  // $q.after($preview);

  // For previewing: pretend we are done with entering the formula here
  var closeParens = function(str) {
    var stack = [], el;
    _.map(str, function(c) {
      if (c === '{') {
        stack.push('}');
      } else if (c === '[') {
        stack.push(']');
      } else if (c === '}' || c === ']') {
        stack.pop();
      }
    });
    while (el = stack.pop()) {
      str += el;
    }
    return str;
  };

  // Coerce the formula to a JSON AST
  var parse = function(str) {
    return jsonlite.parse(closeParens(str));
  };

  // Allow e.g. lowercase names
  var canonicalizeName = function(name) {
    return name.latinize().toLowerCase().replace(/[${}\(\)\\\s]/g, '');
  };
  var displayName = function(name) {
    return name.toLowerCase().replace(/[$]/g, '');
  }

  // Maps text atoms to submittable id: bool value pairs
  var lookupProps = function(f) {
    if (f.and) {
      return {and: _.map(f.and, lookupProps)};
    } else if (f.or) {
      return {or: _.map(f.or, lookupProps)};
    } else {
      // TODO: fuzzy match, make suggestions if missing
      var name, val, prop, atom;

      if (f[0] === "~" || f[0] === "-" || f[0] === "Â¬") {
        name = f.slice(1, f.length);
        val = false;
      } else {
        name = f;
        val = true;
      };

      prop = nameMap[canonicalizeName(name)];
      if (! prop) {
        _lookupErrors.push(name);
      }

      atom = {}
      atom[prop] = val;
      return atom;
    }
  }

  var jsonliteEscape = function(str) {
    if (str.match(/[\s",\[\]{}:]/)) {
      return '"' + str.replace('"', '\\"') + '"';
    } else {
      return str;
    }
  }

  // Redisplay a JSON formula in its lighter weight format
  var lighten = function(f) {
    if (f.and) {
      return "{and: [" + _.map(f.and, lighten).join(", ") + "]}";
    } else if (f.or) {
      return "{or: [" + _.map(f.or, lighten).join(", ") + "]}";
    } else {
      var kv = _.pairs(f)[0]
        , prefix = kv[1] ? "" : "~"
        , dName = idMap[""+kv[0]];
      return jsonliteEscape(prefix + dName);
    }
  }

  var renderPreview = function() {
    if (!nameMap) return;
    var contents = parse($q.val());
    $preview.html(JSON.stringify(lookupProps(contents), null, 2));
  };

  // Fetch the existing property name <~> id mapping
  //   and render what we need to once we have it
  var setNameMaps = function(data) {
    _.each(data, function(id, name) {
      var cName = canonicalizeName(name);
      if (nameMap[cName]) {
        throw "Name " + cName + " already present";
      };
      nameMap[cName] = id;

      var dName = displayName(name);
      idMap[id] = idMap[id] || dName;

      suggestions.push({key: cName, value: dName});
    });

    if ($q.val()) {
      var modifier = "", val = $q.val();
      if (val[0] === "!" || val[0] === "?" || val[0] === ":") {
        modifier = val[0];
        val = val.slice(1, val.length);
      }
      try {
        $q.val(modifier + lighten(JSON.parse(val)));
      } catch (e) {
        logError(["Couldn't lighten formula", val, e]);
      }
    };
    // renderPreview();
  };
  window.localCache.fetch("propertyNames", "@{PropertiesNamesR}", setNameMaps);

  $q.typeahead({
    minLength: 2,
    highlight: false
  }, {
    name: "formula-typeahead",
    displayKey: function(obj) { return obj.prefix + obj.value; },
    source: function(query, cb) {
      // Handle special query types
      if (query[0] == ":") return;
      if (query[0] == "?" || query[0] == "!") {
        query = query.slice(1, query.length);
      }

      var prefix, fragment, sep = query.regexLastIndexOf(/[,\[]/);
      if (sep == -1) {
        prefix = "";
        fragment = query;
      } else {
        prefix = query.slice(0, sep + 1);
        fragment = query.slice(sep + 1, query.length);
      }

      // Include whitespace in the prefix
      var s = /(\s*)(.*)/.exec(fragment);
      prefix += s[1];
      fragment = s[2];

      if (fragment.length < 2 || fragment[0] === "{") {
        cb([]);
      } else {
        // TODO: fuzzy-find suggestions
        var hits = _.select(suggestions, function(s) {
          return s.key.indexOf(fragment) === 0;
        });
        cb(_.map(hits, function(h) {
          h.prefix = prefix;
          return h;
        }));
      }
    }
  });


  // $q.keyup(_.debounce(renderPreview, 500));

  var $errors = $('<div class="alert alert-danger"></div>').hide();
  $q.after($errors);

  var showError = function(e) {
    $errors.show().html(e);
  }

  // Convert shorthand to JSON before submitting the form
  $q.closest("form").submit(function(e) {
    var matchType = "", parsed, corrected, val = $q.val()

    if (val[0] == ":") {
      return true; // Searching by text - don't process any
    } else if (val[0] == "?" || val[0] == "!") {
      matchType = val[0];
      val = val.slice(1, val.length);
    }

    _lookupErrors = [];
    try {
      parsed = parse(closeParens(val));
    } catch (e) {
      showError("Could not parse formula - please be sure it is well-formed");
      logError("Failed to parse formula", val, e);
      return false;
    }

    corrected = lookupProps(parsed);
    if (_lookupErrors.length > 0) {
      showError("Unrecognized properties:" + _lookupErrors.join(", "));
      _lookupErrors = [];
      e.preventDefault();
      return false;
    } else {
      // Some legerdemain so that we don't see the _actual_ submitted content
      var hq = $('<input type="hidden" name="q">').val(matchType + JSON.stringify(corrected));
      $q.attr("name", "");
      $(this).append(hq);
    }
  });

  // TODO: Add a modal help window
  // var help = $('<i class="fa fa-question form-control-feedback clickable"></i>');
  // help.click(function() { });
  // $q.after(help);
  // $q.parent().addClass("has-feedback");
}


$(function() {
  window.piBase.formulaInput($("#navbar-search"));

  $(".markdown").each(function(i, el) {
    var $el = $(el);
    $el.html(markdown($el.html()));
  });

  // TODO: I'd really like a better way of specifiying this
  //   on a field-by-field basis, but Yesod.Bootstrap3 doesn't seem to expose this
  $(".form-markdown textarea").each(function(i, el) {
    var $el = $(el)
      , $preview = $("<div class='well'></div>");
    $el.attr("rows", 10).after($preview);

    var renderPreview = function() {
      $preview.html(markdown($el.val()));
      MathJax.Hub.Queue(["Typeset", MathJax.Hub, $preview.get(0)]);
    };
    renderPreview();

    $el.keyup(_.debounce(renderPreview, 500));
  });

  $("a.search-help").click(function(e) {
    e.preventDefault();
    $('#search-help').modal();
    return false;
  });
});
