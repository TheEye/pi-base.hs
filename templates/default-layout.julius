"use strict";


window.piBase = window.piBase || {}
window.piBase.formulaInput = function($q) {
  var nameMap       = {} // simplified name -> id
    , idMap         = {} // id -> display name
    , suggestions   = []
    , _lookupErrors = []; // TODO: global state bad!

  var logError = function(args) {
    if (typeof(Rollbar) === "undefined") {
      console.error(args);
    } else {
      Rollbar.error.apply(null, args);
    }
  }

  // var $preview = $('<pre></pre>');
  // $q.after($preview);

  // For previewing: pretend we are done with entering the formula here
  var closeParens = function(str) {
    var stack = [], el;
    _.map(str, function(c) {
      if (c === '{') {
        stack.push('}');
      } else if (c === '[') {
        stack.push(']');
      } else if (c === '}' || c === ']') {
        stack.pop();
      }
    });
    while (el = stack.pop()) {
      str += el;
    }
    return str;
  };

  // Coerce the formula to a JSON AST
  var parse = function(str) {
    return jsonlite.parse(closeParens(str));
  };

  // Allow e.g. lowercase names
  var canonicalizeName = function(name) {
    return name.latinize().toLowerCase().replace(/[${}\(\)\\\s]/g, '');
  };
  var displayName = function(name) {
    return name.toLowerCase().replace(/[$]/g, '');
  }

  // Maps text atoms to submittable id: bool value pairs
  var lookupProps = function(f) {
    if (f.and) {
      return {and: _.map(f.and, lookupProps)};
    } else if (f.or) {
      return {or: _.map(f.or, lookupProps)};
    } else {
      // TODO: fuzzy match, make suggestions if missing
      var name, val, prop, atom;

      if (f[0] === "~" || f[0] === "-" || f[0] === "Â¬") {
        name = f.slice(1, f.length);
        val = false;
      } else {
        name = f;
        val = true;
      };

      prop = nameMap[canonicalizeName(name)];
      if (! prop) {
        _lookupErrors.push(name);
      }

      atom = {}
      atom[prop] = val;
      return atom;
    }
  }

  var jsonliteEscape = function(str) {
    if (str.match(/[\s",\[\]{}:]/)) {
      return '"' + str.replace('"', '\\"') + '"';
    } else {
      return str;
    }
  }

  // Redisplay a JSON formula in its lighter weight format
  var lighten = function(f) {
    if (f.and) {
      return "{and: [" + _.map(f.and, lighten).join(", ") + "]}";
    } else if (f.or) {
      return "{or: [" + _.map(f.or, lighten).join(", ") + "]}";
    } else {
      var kv = _.pairs(f)[0]
        , prefix = kv[1] ? "" : "~"
        , dName = idMap[""+kv[0]];
      return jsonliteEscape(prefix + dName);
    }
  }

  var renderPreview = function() {
    if (!nameMap) return;
    var contents = parse($q.val());
    $preview.html(JSON.stringify(lookupProps(contents), null, 2));
  };

  // Fetch the existing property name <~> id mapping
  //   and render what we need to once we have it
  var setNameMaps = function(data) {
    _.each(data, function(id, name) {
      var cName = canonicalizeName(name);
      if (nameMap[cName]) {
        throw "Name " + cName + " already present";
      };
      nameMap[cName] = id;

      var dName = displayName(name);
      idMap[id] = idMap[id] || dName;

      suggestions.push({key: cName, value: dName});
    });

    if ($q.val()) {
      var modifier = "", val = $q.val();
      if (val[0] === "!" || val[0] === "?" || val[0] === ":") {
        modifier = val[0];
        val = val.slice(1, val.length);
      }
      try {
        $q.val(modifier + lighten(JSON.parse(val)));
      } catch (e) {
        logError(["Couldn't lighten formula", val, e]);
      }
    };
    // renderPreview();
  };
  window.localCache.fetch("propertyNames", "@{PropertiesNamesR}", setNameMaps);



  // $q.keyup(_.debounce(renderPreview, 500));

  var $errors = $('<div class="alert alert-danger"></div>').hide();
  $q.after($errors);

  var showError = function(e) {
    $errors.show().html(e);
  }

  // Convert shorthand to JSON before submitting the form
  $q.closest("form").submit(function(e) {
    var matchType = "", parsed, corrected, val = $q.val()

    if (val[0] == ":") {
      return true; // Searching by text - don't process any
    } else if (val[0] == "?" || val[0] == "!") {
      matchType = val[0];
      val = val.slice(1, val.length);
    }

    _lookupErrors = [];
    try {
      parsed = parse(closeParens(val));
    } catch (e) {
      showError("Could not parse formula - please be sure it is well-formed");
      logError("Failed to parse formula", val, e);
      return false;
    }

    corrected = lookupProps(parsed);
    if (_lookupErrors.length > 0) {
      showError("Unrecognized properties:" + _lookupErrors.join(", "));
      _lookupErrors = [];
      e.preventDefault();
      return false;
    } else {
      // Some legerdemain so that we don't see the _actual_ submitted content
      var hq = $('<input type="hidden" name="q">').val(matchType + JSON.stringify(corrected));
      $q.attr("name", "");
      $(this).append(hq);
    }
  });

  // TODO: Add a modal help window
  // var help = $('<i class="fa fa-question form-control-feedback clickable"></i>');
  // help.click(function() { });
  // $q.after(help);
  // $q.parent().addClass("has-feedback");
}

$(function() {
  window.piBase.formulaInput($("#navbar-search"));

});
